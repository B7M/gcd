In lessons up to this point, the analyses you've done have generally been carried out with a single dataset (e.g.: data from a single Google Sheet). However, there will be many cases as a data scientist where the data for your project will be stored across a number of different spreadsheets that are all related to one another. In this lesson, we'll discuss what relational data are, why you would want to store data in this way, and how to work with these types of data in R Studio.

Relational data can be thought of as information being stored across many tables, with each table being related to all the other tables. Each table is linked to every other table by a set of unique identifiers. To better understand this, let's consider a toy example. We mentioned this example in the introductory lesson in this course, and we'll return to it now. Consider a town where you have a number of different restaurants. In one table you have information about these restaurants including, where they are located and what type of food they serve. You then have a second table where information about health and safety inspections is stored. Each inspection is a different row and the date of the inspection, the inspector, and the safety rating are stored in this table. Finally, you have a third table. This third table contains information pulled from an API, regarding the number of stars given to each restaurant, as rated by people online. Each table contains different bits of information; however, there is a common column ID in each of the tables. This allows the information to be linked between the tables. 

The restaurant with the ID "JJ29JJ" in the restaurant table would refer to the same restaurant with the ID "JJ29JJ" in the health inspections table, and so on. The values in this ID column are known as unique identifiers because they uniquely identify each restaurant. No two restaurants will have the same ID, and the same restaurant will always have the same ID, no matter what table you're looking at. The fact that these tables have unique identifiers connecting each table to all the other tables makes this example relational data.

Storing data in this way has a number of advantages; however, the three most important are Efficient Data Storage, that it Avoids Ambiguity and allows for data Privacy. In terms of efficient Data Storage, By storing each bit of information in a separate table, you limit the need to repeat information. Taking our example above, imagine if we included everything in a single table. This means that for each inspection, we would copy and paste the restaurant's address, type, and number of stars every time the facility is inspected. If a restaurant were inspected 15 times, this same information would be unnecessarily copy and pasted in each row! To avoid this, we simply separate out the information into different tables and relate them by their unique identifiers. 

Relational data also allows us to Avoid Ambiguity. Take a look at the first table: "restaurant" here. You may notice there are two different restaurants named "Taco Stand." However, looking more closely, they have a different ID and a different address. They're even different types of restaurants. So, despite having the same name, they actually are two different restaurants. The unique identifier makes this immediately clear! And finally, this type of data allows for privacy - In using relational data, if there is ever information that is private and only some people should have access to, using this system simplifies that. You can restrict access to some of the data to ensure only those who should have access are able to access the data.

Now that we have an idea of what relational data are, let's spend a second talking about how relational data are stored. Relational data are stored in databases. The most common database is SQL Lite. In order to work with data in databases, there has to be a way to query or search the database for the information you're interested in. SQL queries search through SQL Lite databases and return the information you ask for in your query. For example, a query of the above example may look to obtain information about any restaurant that was inspected after July 1st of 2018. One would then use SQL commands to carry out this query and return the information requested. While we won't be discussing how to write SQL commands in-depth here, we will be discussing how to use the R package RSQL Lite to connect to a SQL Lite database using RSQL Lite, and how to work with relational data using D plier and DB plier.

To better understand databases and how to work with relational data, let's just start working with data from a database! The data we'll be using are from a database frequently used to practice working with relational data: chinook dot DB. The database includes 11 tables with data that represents a digital media store. The data includes information generally related to media, artists, artists' work, and those who purchase artists' work (customers). More information about the details of how the tables are related to one another can be found at the provided link. For our purposes though, we're only going to describe two of the tables we'll be using in our example in this lesson. We're going to be looking at data in the artists and albums tables. artists and albums are related by the column Artist ID.

Without any more details, let's get to it! Here you'll see the code to install and load the RSQL Lite package. You'll then download the chinook sample database, connect to the database, and first obtain a list of the tables in the database.

The output from DB List Tables will include 13 tables. Among them will be the two tables we're going to work through in our example: artists and albums.

In this example, we're downloading a database and working with the data locally. However, more often, when working with SQL Lite databases, you'll be connecting remotely. Using the RSQL Lite package is particularly helpful in this case because it allows you to connect to and query the database from R without reading all the data in. This is helpful in the case of very large databases, where you'll want to avoid copying all the data and will instead want to only work with the parts of the database you need. To access these tables within R Studio, we'll have to install the package DB plier, which enables us to access the parts of the database we're going to be working with. While DB plier has to be loaded to work with databases, you likely won't notice that you're using it beyond that. Otherwise, you'll just work with the files as if you were working with D pliers functions! After installing and loading DB plier, we'll be able to use the helpful TBL function to extract the two tables we're interested in working with!

Doing so, we see that the two tables have the Artist ID column in common. We'll spend a bit more time on this topic later, but for now, we are going to simply join these two data sets together on the basis of this common ID to create a single data frame. For this example, we are going to want to include the artist name for each of the albums.  

We will have an entire lesson dedicated to joins in next week, but for now, you can have a preview of how useful these commands can be in bringing together data from multiple sources into a single object on the basis of a common column, by following the provided commands.

As mentioned briefly above, most often when working with databases, you won't be downloading the entire database. Instead, you'll connect to a server somewhere else where the data live and query the data (search for the parts you need) from within R.. For example, in this lesson we downloaded the entire chinook database, but only ended up using artists and albums. In the future, instead of downloading all the data, you'll just connect to the database and work with the parts you need. This will require connecting to the database with host, user, and password. This information will be provided by the database's owners, but the syntax for entering this information into R to connect to the database would look something like what is shown here. While not being discussed in detail here, it's important to know that connecting to remote databases from R is possible and that this allows you to query the database without reading all the data from the database into R..   

For some practice on using R to query SQL databases, follow the provided RSQL Lite tutorials by Taylor W Brown and Josh R Bruce. In this lesson we discussed what relational data are, the benefits of relational data, and how to work with them in R.. This led to a discussion about the package RSQL Lite, which allows you to connect to and make queries from databases. Finally, we touched very briefly on how to connect to a remote database from within R. 